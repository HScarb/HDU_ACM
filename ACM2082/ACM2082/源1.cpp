/*假设有x1个字母A， x2个字母B,..... x26个字母Z，同时假设字母A的价值为1，
字母B的价值为2,..... 字母Z的价值为26。那么，对于给定的字母，
可以找到多少价值<=50的单词呢？单词的价值就是组成一个单词的所有字母的价值之和，
比如，单词ACM的价值是1+3+14=18，单词HDU的价值是8+4+21=33。
(组成的单词与排列顺序无关，比如ACM与CMA认为是同一个单词）。
2(两组测试示例）
1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
9 2 6 2 10 2 2 5 6 1 0 2 7 0 2 2 7 5 10 6 10 2 10 6 1 9

解第一组的情况：第一组结果为7种
可列方程：G(x) =（1+1*x^1)*(1+1*x^2)*(1+1*x^3)=1+x+x^2+2*x^3+x^4+x^5+x^6;
组合的种数共：1+1+2+1+1+1=7
1+1*x^2 表示 价值2的字母B有1个（即系数1） 1+1*x^2=1*x^0+1*x^2

若需解第二组亦可用同样的方法（母函数）解答。
g(x) =（1+9*x^1)(1+2*x^2)(1+6*x^3)*...*(1+9*x^26)
*/
// 典型用母函数求解题

#include<iostream>
using namespace std;
int c1[55], c2[55];
int main()
{                         //c1表示各项单词组合价值不大于50的组合的数目
	int n;                //c2表示中间量，保存每一次的情况
	int i, j, k;
	int sum;
	int a[27] = { 0 };
	cin >> n;
	while (n--)
	{
		for (i = 1; i < 27; i++)
			cin >> a[i];
		memset(c2, 0, sizeof(c2));
		memset(c1, 0, sizeof(c1));
		for (i = 0; i < 51 && i <= a[1]; i++)
			c1[i] = 1;
		for (i = 2; i <= 26; i++)    //i表示第i个表达式
		{                     //j表示前面i个表达式累乘后的表达式里第j个变量
			for (j = 0; j < 51; j++)
			{
				for (k = 0; k + j < 51 && k <= a[i] * i; k += i)//关键。   k表示第j个的指数 
					c2[k + j] += c1[j];
			}
			for (j = 0; j < 51; j++)
			{
				c1[j] = c2[j];
				c2[j] = 0;
			}
		}
		sum = 0;
		for (i = 1; i <= 50; i++)
			sum += c1[i];
		cout << sum << endl;
	}return 0;
}